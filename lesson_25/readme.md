# Повторяем
* Процесс и поток разделяют общее адресное пространство.
* В однопоточном процессе task_struct потока имеет PID процесса
# Новое:
* В многопоточном процессе task_struct первого потока имеет PID процесса, а все последующие потоки создаются с новыми PID-ами, и у всех потоков выставляется tgid (Thread Group Id) равны PID-у процесса
* системный вызов getpid() для каждого потока будет возвращать task_struct::tgid
* task_struct также позволяет представить абстракцию: поток ядра
* Потоки ядра бывают полезны когда нужно что-то делать не переключаясь в user-space, они выполняются только в контексте ядра и у них нет своего адресного пространства.
* В пространстве ядра никак не защищается память, доступно всё оборудование
* Поток ядра создаётся функцией kernel_thread (а ещё kernel_thread_on_cpu )
* Имена функций начинающиеся с _ нужно использовать только если 100% знаешь, что делаешь
* В ядре есть процесс с PID=0: swapper или idle, он создаётся в процессе инициализации ядра, его данные выделяются статически, от него создаётся процесс init. Он выполнятеся, когда в системе нет процессов для выполнения. Шлёт инструкцию HALT, бездействие CPU

# Взаимосвязи процессов
В task_struct есть следующие поля:
1. real_parent - указатель на процесс, который породил данный процесс
2. parent - указывает на текущего родителя (трассировка, дебаг)
3. children - голова списка потомков
4. sibling - голова списка процессов, имеющих того же родителя
5. group_leader - указатель на task_struct процесса!
6. signal->pgrp - группа процессов
7. signal->session - сессия процессов

# Завершение процесса
системный вызов exit() ( man 2 exit и man 3 exit )

| c lib                 | system call   | kernel function   |
| exit()                | exit_group()  | do_group_exit     |
| pthread_exit()()      | _exit()       | do_exit           |

kernel/exit.c - там do_exit
do_task_dead - вызывает код планировщика!
release_task - удаляет саму структуру
