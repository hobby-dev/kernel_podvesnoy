# Последнее слово про списки:
```
struct list_head {
    struct list_head * next;
    struct list head * prev;
]

struct task_struct {
    ...
    struct list_head children;
    ...
}

```

Как только мы добавляем list_head в свою струтуру, для получения доступа к элементам списка мы можем использовать:
```
struct task_struct * list_entry(struct list_head * p, struct task_struct, children));
см. также:
containerof
list_for_each()
list_for_each_entry()

```

# Планировщик
Политика планирования - стратегия определяет какой процесс должен быть выполнен в текущий момент времени, "что мы делаем сейчас".
Цель политики - как можно больше процессов в единицу времени и как можно меньшее время ожидания отдельного процесса.

## С каким процессами работает планировщик:
1. Ожидающие ввода в систему (загрузки в память) -> ввод
2. Ожидающие запуска (ещё не начали исполняться) -> запуск
3. Приостановленные, или ожидающие активации (уже работают, но сейчас не соревнуются за процессор) -> активация
4. Активные (ожидают процессора в очереди) -> пуск
5. Выполняющиеся (уже на процессоре) -> завершение
6. Завершённые

Выполняется -> истекло время или произведено чтение с диска -> Заблокирован

## На всех уровнях свои политики планирования.

* За запуск отвечает планировщик верхнего уровня. Определяет степень многозадачности. Т.е. сколько процессов будет запущенно всего.
* Активацией процессов занимается планировщик среднего уровня. Ставит их в очередь за процессором.
* Пуск процессов осуществляет планировщик нижнего уровня. Определяет, какая задача будет выполняться на процессоре.

## Какое может быть планировние
1. С вытеснением (preemtive) - есть накладные расходы на переключение
2. Без вытеснения (non preemptive) - может произойти монопольный захват ресурсов, но система становится более предсказуемой

## Приоритеты:
1. статические - очень простой алгоритм планирования, но есть риск монопольного захвата ресурсов
2. динамические - более сложный алгоритм планирования, но лучшее поведение системы вцелом

## Цели стратегии планирования
1. Максимальная пропускная способность (больше процессов в единицу времени)
2. Минимальное время отклика интерактивных приложений для всех пользователей
3. Не допускать бесконечного откладывания
4. Учёт приоритетов
5. Снижение накладных расходы
6. Обеспечение предсказуемости системы

