# Последнее слово про списки:
```
struct list_head {
    struct list_head * next;
    struct list head * prev;
]

struct task_struct {
    ...
    struct list_head children;
    ...
}

```

Как только мы добавляем list_head в свою струтуру, для получения доступа к элементам списка мы можем использовать:
```
struct task_struct * list_entry(struct list_head * p, struct task_struct, children));
см. также:
containerof
list_for_each()
list_for_each_entry()

```

# Планировщик
Политика планирования - стратегия определяет какой процесс должен быть выполнен в текущий момент времени, "что мы делаем сейчас".
Цель политики - как можно больше процессов в единицу времени и как можно меньшее время ожидания отдельного процесса.

## С каким процессами работает планировщик:
1. Ожидающие ввода в систему (загрузки в память) -> ввод
2. Ожидающие запуска (ещё не начали исполняться) -> запуск
3. Приостановленные, или ожидающие активации (уже работают, но сейчас не соревнуются за процессор) -> активация
4. Активные (ожидают процессора в очереди) -> пуск
5. Выполняющиеся (уже на процессоре) -> завершение
6. Завершённые

Выполняется -> истекло время или произведено чтение с диска -> Заблокирован

## На всех уровнях свои политики планирования.

* За запуск отвечает планировщик верхнего уровня. Определяет степень многозадачности. Т.е. сколько процессов будет запущенно всего.
* Активацией процессов занимается планировщик среднего уровня. Ставит их в очередь за процессором.
* Пуск процессов осуществляет планировщик нижнего уровня. Определяет, какая задача будет выполняться на процессоре.

## Какое может быть планировние
1. С вытеснением (preemtive) - есть накладные расходы на переключение
2. Без вытеснения (non preemptive) - может произойти монопольный захват ресурсов, но система становится более предсказуемой

## Приоритеты:
1. статические - очень простой алгоритм планирования, но есть риск монопольного захвата ресурсов
2. динамические - более сложный алгоритм планирования, но лучшее поведение системы вцелом

## Цели стратегии планирования
1. Максимальная пропускная способность (больше процессов в единицу времени)
2. Минимальное время отклика интерактивных приложений для всех пользователей
3. Не допускать бесконечного откладывания
4. Учёт приоритетов
5. Снижение накладных расходы
6. Обеспечение предсказуемости системы

## Свойства стратегии планирования
1. Равноправие для процессов - все процессы обрабатываются одинаково
2. Предсказуемость - один и тот же процесс в одних и тех же условиях выполняется примерно за одно и то же время
3. Масштабируемость

## Критерии планирования должны учитывать:
* CPU-bound процессы (интенсивно использующие процессор)
* I/O-bound процессы (интенсивно использующие ввод-вывод)
* batch (пакетные) процессы - не нужно взаимодействие с пользователем, лучше переносят задержку во времени отклика
* interactice - нужно взаимодействие с пользователем

## Квант времени (time slice)
Время, выделяемое процессу для выполнения на процессоре.

# Истории планировщиков в Linux

## В ядре 2.4
Был простой планировщик, прозрачный алгоритм, плохо масштабировался на больших системах

## В ядре 2.5
Появился планировщик O(1), т.е. хорошо масштабировался, но было плохо с интерактивностью

## В ядре 2.6
Справедливый планировщик - учитывает использованное процессорное время.


# Задания:

Алгоритмы планирования: FIFO, циклическое планирование, кратчайший процесс первый, по наименьшему оставшемуся времени, справедливое планирование - рассмотреть и закодить на Си.
```
struct my_awesome_process
{
    int start_time;
    int time_to_complete;
    int priority;
    ...
}
```
За какое время все процессы будут выполнены

